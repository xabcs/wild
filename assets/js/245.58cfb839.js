(window.webpackJsonp=window.webpackJsonp||[]).push([[245],{601:function(t,e,_){"use strict";_.r(e);var v=_(7),o=Object(v.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"k8s调度策略之优先级和抢占-驱逐详解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#k8s调度策略之优先级和抢占-驱逐详解"}},[t._v("#")]),t._v(" k8s调度策略之优先级和抢占，驱逐详解")]),t._v(" "),e("h2",{attrs:{id:"_1-调度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-调度"}},[t._v("#")]),t._v(" 1. 调度")]),t._v(" "),e("p",[e("code",[t._v("调度是指将pod分配到合适的节点上")]),t._v("，Kube-scheduler通过watch机制监听kube-apiserver，查询已经新建但还未调度的pod，根据调度策略将pod调度至集群内最合适的node.\n:::")]),t._v(" "),e("h3",{attrs:{id:"_1-1-调度流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-调度流程"}},[t._v("#")]),t._v(" 1.1. 调度流程")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("用户提交创建pod的请求")])]),t._v(" "),e("li",[e("p",[t._v("api-server 处理用户请求，存储用户数据到ETCD")])]),t._v(" "),e("li",[e("p",[t._v("kube-schedule中的informer组件监听api-server,筛选出space.nodeName=''的pod列表，循环遍历的为每个pod尝试分配节点， kube-scheduler 给一个 Pod 做调度选择时包含两个步骤：")]),t._v(" "),e("p",[e("strong",[t._v("第一阶段")]),e("code",[t._v("预选阶段，过滤节点，调度器通过Predicate算法过滤掉不满足条件的节点")]),t._v("\n主要的预选算法包括")]),t._v(" "),e("ul",[e("li",[e("p",[e("code",[t._v("资源相关算法")])]),t._v(" "),e("ul",[e("li",[e("p",[e("code",[t._v("PodFitsResources")])]),t._v(" "),e("p",[t._v("作用：检查节点是否有足够的资源（CPU、内存、GPU 等）满足 Pod 的 requests。")]),t._v(" "),e("p",[t._v("规则：\n节点剩余资源 ≥ Pod 的 requests（需考虑已调度 Pod 的资源占用）。\n如果 Pod 未指定 requests，默认按 limits 的 100% 计算（可能导致资源不足）。")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("CheckNodeMemoryPressure / CheckNodeDiskPressure / CheckNodePIDPressure")])]),t._v(" "),e("p",[t._v("作用：检查节点是否处于资源压力状态。\n内存压力：节点剩余内存不足。\n磁盘压力：节点磁盘空间或 inode 不足。\nPID 压力：节点进程 ID 不足。")]),t._v(" "),e("p",[t._v("规则：若节点存在压力，则跳过该节点（除非 Pod 容忍 memoryPressure、diskPressure 等污点）。")])])])]),t._v(" "),e("li",[e("p",[e("code",[t._v("选择器与标签算法")])]),t._v(" "),e("ul",[e("li",[e("p",[e("code",[t._v("MatchNodeSelector")])]),t._v(" "),e("p",[t._v("作用：检查节点是否匹配 Pod 的 nodeSelector 或 nodeAffinity 硬性规则。")]),t._v(" "),e("p",[t._v("规则：\nnodeSelector：节点必须包含所有指定标签。\nnodeAffinity（requiredDuringScheduling）：必须满足所有硬性匹配条件。")])]),t._v(" "),e("li",[e("p",[t._v("PodFitsHostPorts\n作用：检查节点上是否有 Pod 声明的 hostPort 已被占用。")]),t._v(" "),e("p",[t._v("规则：若节点上已有 Pod 占用了相同的 hostPort，则排除该节点。")])])])]),t._v(" "),e("li",[e("p",[e("code",[t._v("存储相关算法")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("VolumeZonePredicate\n作用：检查持久卷（PV）的可用区是否与节点匹配。")]),t._v(" "),e("p",[t._v("规则：若 Pod 使用特定可用区的 PV（如 topology.kubernetes.io/zone），则节点必须位于同一可用区。")])]),t._v(" "),e("li",[e("p",[t._v("VolumeBindingPredicate\n作用：检查节点是否能绑定 Pod 所需的 PVC（Persistent Volume Claim）。")]),t._v(" "),e("p",[t._v("规则：若 PVC 是 WaitForFirstConsumer 模式，调度器会延迟绑定，直到选择节点。\n节点必须满足 PVC 的存储类（StorageClass）、容量等要求。")])])])]),t._v(" "),e("li",[e("p",[e("code",[t._v("亲和性/反亲和性算法")])]),t._v(" "),e("ul",[e("li",[e("p",[e("code",[t._v("InterPodAffinity")]),t._v("\n作用：检查 Pod 的亲和性/反亲和性硬性规则（requiredDuringScheduling）。")]),t._v(" "),e("p",[t._v("规则：Pod 亲和性：必须与指定 Pod 在同一个拓扑域（如节点、可用区）。\nPod 反亲和性：必须避免与指定 Pod 在同一个拓扑域。")])])])]),t._v(" "),e("li",[e("p",[e("code",[t._v("污点与容忍算法")]),t._v("\n作用：检查 Pod 是否容忍节点的污点（Taints）。\n规则：若节点有污点且 Pod 未声明对应的容忍（Toleration），则排除该节点。\n污点效果（Effect）为 NoSchedule 时，必须严格匹配容忍。")])])])])]),t._v(" "),e("p",[t._v("Predicate算法（预选算法）执行流程:")]),t._v(" "),e("blockquote",[e("ul",[e("li",[e("code",[t._v("并行过滤")]),t._v("：调度器并行执行所有 Predicate 算法，快速缩小候选节点范围。")]),t._v(" "),e("li",[e("code",[t._v("顺序无关性")]),t._v("：各算法之间无依赖关系，最终结果取逻辑“与”（所有条件均需满足）。")]),t._v(" "),e("li",[e("code",[t._v("短路优化")]),t._v("：若某算法过滤后无剩余节点，直接终止流程，Pod 进入 Pending 状态。")])])]),t._v(" "),e("ul",[e("li",[e("p",[e("strong",[t._v("第二阶段")]),t._v(" "),e("code",[t._v("优选阶段（priorities）：为上一阶段选出来的node进行打分，选出得分最高的")]),t._v("\n主要的优选阶段算法包括")]),t._v(" "),e("ul",[e("li",[e("p",[e("code",[t._v("资源均衡类的")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("LeastRequestedPriority 最低请求优先算法")]),t._v(" "),e("p",[t._v("规则：选择（CPU 和 Memory）request最低的的宿主机")])]),t._v(" "),e("li",[e("p",[t._v("BalancedResourceAllocation 资源均衡分配")]),t._v(" "),e("p",[t._v("规则：优先选择 CPU 和内存利用率接近 的节点，避免单一资源过载")])])])]),t._v(" "),e("li",[e("p",[e("code",[t._v("亲和性权重类算法")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("NodeAffinityPriority（节点亲和性权重）")]),t._v(" "),e("p",[t._v("作用：为符合 nodeAffinity 软性规则（preferredDuringScheduling）的节点加分。")]),t._v(" "),e("p",[t._v("规则：根据 preference 中的 weight 值增加分数。")])]),t._v(" "),e("li",[e("p",[t._v("InterPodAffinityPriority（Pod 亲和性/反亲和性权重）")]),t._v(" "),e("p",[t._v("作用：根据 Pod 亲和性/反亲和性的软性规则（preferredDuringScheduling）调整分数。\n规则：")]),t._v(" "),e("p",[t._v("Pod 亲和性：与目标 Pod 处于同一拓扑域的节点加分。\nPod 反亲和性：与目标 Pod 处于同一拓扑域的节点减分。")])]),t._v(" "),e("li",[e("p",[t._v("TaintTolerationPriority（污点容忍优先）")]),t._v(" "),e("p",[t._v("作用：为容忍更多污点的节点加分（需结合 PodToleratesNodeTaints Predicate 使用）。")]),t._v(" "),e("p",[t._v("规则：优先选择容忍度高的节点（如专用节点池）\n"),e("code",[t._v("NodeAffinityPriority、TaintTolerationPriority 和 InterPodAffinityPriority 这三种 Priority，一个 Node 满足上述规则的字段数目越多，它的得分就会越高")])])])])]),t._v(" "),e("li",[e("p",[t._v("其他算法")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("ImageLocalityPriority（镜像本地性优先）")]),t._v(" "),e("p",[t._v("作用：优先选择已存在 Pod 所需镜像的节点，减少镜像拉取时间。")])]),t._v(" "),e("li",[e("p",[t._v("VolumeZonePredicate（存储卷可用区匹配）")]),t._v(" "),e("p",[t._v("作用：优先选择与持久卷（PV）处于同一可用区（Zone）的节点。")]),t._v(" "),e("p",[t._v("规则：减少跨可用区访问存储的延迟。")])])])])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("第三阶段")]),t._v(" "),e("code",[t._v("binding阶段（选定阶段）")]),t._v("：选择得分最高的Node节点和pod进行binding操作，将结果存储在etcd中，选择出来的node节点对应的kubelet会去执行创建pod的相关操作。\n:::")])])]),t._v(" "),e("h2",{attrs:{id:"_3-优先级机制-抢占机制-priority"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-优先级机制-抢占机制-priority"}},[t._v("#")]),t._v(" 3. 优先级机制/抢占机制（"),e("strong",[t._v("Priority")]),t._v("）")]),t._v(" "),e("h3",{attrs:{id:"_3-1-概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-概念"}},[t._v("#")]),t._v("  3.1 概念：")]),t._v(" "),e("p",[t._v("作用于调度阶段，当资源不足时，决定哪些pod被优先调度或者抢占的机制。高优先级的pod被调度失败后，可以驱逐低优先级pod的方式抢占低优先级pod的资源完成调度。")]),t._v(" "),e("h3",{attrs:{id:"_3-2-如何使用优先级和抢占机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-如何使用优先级和抢占机制"}},[t._v("#")]),t._v(" 3.2 如何使用优先级和抢占机制")]),t._v(" "),e("ul",[e("li",[t._v("新建一个PriorityClass对象，设置优先级数值")]),t._v(" "),e("li",[t._v("在Pod的spec的priorityClassName引用PriorityClas")]),t._v(" "),e("li",[t._v("当高优先级Pod无法调度时，调度器尝试驱逐低优先级Pod以释放资源")])]),t._v(" "),e("h2",{attrs:{id:"_4-qos服务质量等级机制-驱逐机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-qos服务质量等级机制-驱逐机制"}},[t._v("#")]),t._v(" 4. Qos服务质量等级机制（驱逐机制）")]),t._v(" "),e("h3",{attrs:{id:"_4-1-概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-概念"}},[t._v("#")]),t._v(" 4.1 概念:")]),t._v(" "),e("p",[t._v("QoS 等级作用于运行阶段，是 Kubernetes 在 "),e("strong",[t._v("运行时（节点资源不足时）")]),t._v(" 决定哪些 Pod 会被优先驱逐的机制。")]),t._v(" "),e("p",[t._v("它根据 Pod 的资源请求（Requests）和限制（Limits）的配置，将 Pod 分为三个等级：")]),t._v(" "),e("ol",[e("li",[e("p",[e("strong",[t._v("Guaranteed")]),t._v("（最高）：")]),t._v(" "),e("ul",[e("li",[t._v("所有容器的 CPU/Memory 均设置 "),e("code",[t._v("requests")]),t._v(" limits`。")]),t._v(" "),e("li",[e("strong",[t._v("最后被驱逐")]),t._v("。")])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("Burstable")]),t._v("（中等）：")]),t._v(" "),e("ul",[e("li",[t._v("至少一个容器设置了 "),e("code",[t._v("requests")]),t._v("，但未满足 "),e("code",[t._v("requests")]),t._v(" limits`。")]),t._v(" "),e("li",[e("strong",[t._v("驱逐优先级低于 BestEffort")]),t._v("。")])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("BestEffort")]),t._v("（最低）：")]),t._v(" "),e("ul",[e("li",[t._v("所有容器均未设置 "),e("code",[t._v("requests")]),t._v(" 和 "),e("code",[t._v("limits")]),t._v("。")]),t._v(" "),e("li",[e("strong",[t._v("最先被驱逐")]),t._v("。")])])])]),t._v(" "),e("h2",{attrs:{id:"_5-优先级和服务质量等级两者的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-优先级和服务质量等级两者的关系"}},[t._v("#")]),t._v(" 5. 优先级和服务质量等级"),e("strong",[t._v("两者的关系")])]),t._v(" "),e("p",[t._v("两者的核心区别")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"left"}},[t._v("特性")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("QoS 等级")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("优先级/抢占机制")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("strong",[t._v("作用阶段")])]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("运行时（节点资源不足时）")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("调度阶段")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("strong",[t._v("目标")])]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("决定哪些 Pod 被优先驱逐")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("决定哪些 Pod 被优先调度或抢占")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("strong",[t._v("依赖配置")])]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("资源 "),e("code",[t._v("requests/limits")])]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[e("code",[t._v("PriorityClass")])])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("strong",[t._v("触发条件")])]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("节点资源压力（如 OOM）")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("调度器发现资源不足")])])])]),t._v(" "),e("p",[t._v("尽管两者独立，但在实际场景中会共同影响 Pod 的生命周期：")]),t._v(" "),e("h4",{attrs:{id:"场景-1-调度阶段的抢占"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#场景-1-调度阶段的抢占"}},[t._v("#")]),t._v(" "),e("strong",[t._v("场景 1：调度阶段的抢占")])]),t._v(" "),e("ul",[e("li",[e("p",[e("strong",[t._v("优先级决定抢占顺序")]),t._v("：")]),t._v(" "),e("ul",[e("li",[t._v("高优先级 Pod 触发抢占时，只会驱逐 "),e("strong",[t._v("优先级更低")]),t._v(" 的 Pod。")]),t._v(" "),e("li",[e("strong",[t._v("与 QoS 等级无关")]),t._v("：即使被抢占的 Pod 是 "),e("code",[t._v("Guaranteed")]),t._v("，只要其优先级更低，仍然会被驱逐。")])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("QoS 影响抢占后的稳定性")]),t._v("：")]),t._v(" "),e("ul",[e("li",[t._v("如果高优先级 Pod 的 QoS 为 "),e("code",[t._v("BestEffort")]),t._v("，虽然它被成功调度，但在节点资源不足时可能被优先驱逐。")])])])]),t._v(" "),e("h4",{attrs:{id:"场景-2-运行时的驱逐"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#场景-2-运行时的驱逐"}},[t._v("#")]),t._v(" "),e("strong",[t._v("场景 2：运行时的驱逐")])]),t._v(" "),e("ul",[e("li",[e("p",[e("strong",[t._v("QoS 决定驱逐顺序")]),t._v("：")]),t._v(" "),e("ul",[e("li",[t._v("当节点资源不足（如内存压力）时，"),e("code",[t._v("BestEffort")]),t._v(" Pod 会被优先驱逐，无论其优先级如何。")]),t._v(" "),e("li",[e("strong",[t._v("优先级不直接影响运行时驱逐")]),t._v("：即使一个 "),e("code",[t._v("BestEffort")]),t._v(" Pod 优先级很高，它仍可能被驱逐。")])])])])])}),[],!1,null,null,null);e.default=o.exports}}]);